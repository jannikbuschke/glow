using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.VisualStudio.Services.Common;

namespace Glow.TypeScript
{
    public static class Extensions
    {
        public static string CamelCase(this string value)
        {
            return (char.ToLowerInvariant(value[0]) + value.Substring(1))
                .Replace("_", string.Empty);
        }

        public static bool IsEnumerable(this Type t)
        {
            return t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IEnumerable<>) || t.GetInterfaces().Any(
                i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IEnumerable<>));
        }

        public static void AddTypescriptGeneration(
            this IServiceCollection services,
            Assembly[] assembliesToScan
        )
        {
            IEnumerable<Type> profileTypes = assembliesToScan.SelectMany(v => v.GetTypes())
                .Where(v => v.IsSubclassOf(typeof(TypeScriptProfile)));
            //var schemas = new WorkflowSchemas();

            var entities = new StringBuilder();
            var allEntityNames = new List<string>();

            var builder = new StringBuilder();
            builder.AppendLine($"// this file is autogenerated. To not edit.");
            builder.AppendLine("");

            foreach (Type profileType in profileTypes)
            {
                var profile = Activator.CreateInstance(profileType) as TypeScriptProfile;

                allEntityNames.AddRange(profile.Types.Select(v => v.Name));

                foreach (Type type in profile.Types)
                {
                    entities.AppendLine(@$"  export type {type.Name} = ""{type.FullName}""");

                    builder.AppendLine($"export interface {type.Name} {{");
                    type.GetProperties(BindingFlags.Public | BindingFlags.Instance).ForEach(v =>
                    {
                        builder.AppendLine($"  {v.Name.CamelCase()}: {v.PropertyType.ToTsType()}");
                    });
                    builder.AppendLine("}");
                    builder.AppendLine("");

                    builder.AppendLine($"export const default{type.Name}: {type.Name} = {{");
                    type.GetProperties(BindingFlags.Public | BindingFlags.Instance).ForEach(v =>
                    {
                        var value = v.PropertyType.DefaultValue();// v.PropertyType.IsValueType ? Activator.CreateInstance(v.PropertyType) : "null";
                        builder.AppendLine($"  {v.Name.CamelCase()}: {value ?? "null"},");
                    });
                    builder.AppendLine("}");
                    builder.AppendLine("");
                }
            }
            builder.AppendLine("export module Entities {");

            builder.AppendLine(entities.ToString());

            builder.AppendLine($"  export type All = {string.Join(" | ", allEntityNames)}");
            builder.AppendLine("}");

            System.IO.File.WriteAllText("web/src/my-models.ts", builder.ToString());
        }

        public static string DefaultValue(this Type t)
        {
            var types = new Dictionary<Type, string>
            {
                { typeof(string), @"""""" },
                { typeof(int), "0" },
                { typeof(int?), "null" },
                { typeof(DateTime), @"""1/1/0001 12:00:00 AM""" },
                { typeof(DateTime?), "null" },
                { typeof(Guid), @"""00000000-0000-0000-0000-000000000000""" },
                { typeof(Guid?), "null" },
                { typeof(bool), "false" },
                { typeof(bool?), "null" },
                { typeof(Dictionary<string, string>), "{}" },
                { typeof(Dictionary<string, int>), "{}" },
                { typeof(Dictionary<string, object>), "{}" },
            };

            if (types.TryGetValue(t, out var result))
            {
                return result;
            }

            if (t.IsEnumerable())
            {
                return "[]";
            }

            return "null as any";// $"default{t.Name}";
        }

        public static string ToTsType(this Type t)
        {
            var types = new Dictionary<Type, string>
            {
                { typeof(string), "string" },
                { typeof(int), "number" },
                { typeof(int?), "number | null" },
                { typeof(DateTime), "string" },
                { typeof(DateTime?), "string | null" },
                { typeof(Guid), "string" },
                { typeof(Guid?), "string | null" },
                { typeof(bool), "boolean" },
                { typeof(bool?), "boolean | null" },
                { typeof(Dictionary<string, string>), "{ [key: string]: string }" },
                { typeof(Dictionary<string, int>), "{ [key: string]: number }" },
                { typeof(Dictionary<string, object>), "{ [key: string]: any }" },
                { typeof(object), "any" }
            };

            if (types.TryGetValue(t, out var result))
            {
                return result;
            }

            if (t.IsEnumerable())
            {
                return $"{(t.GetGenericArguments().FirstOrDefault() ?? typeof(object)).ToTsType()}[]";
            }

            return t.Name;
        }
    }
}

