using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Glow.Core.Typescript
{
    public static class Render
    {
        public static void ToDisk(TypeCollection types, string path)
        {
            var builder = new StringBuilder();

            builder.AppendLine($"/* this file is autogenerated. Do not edit. */");
            builder.AppendLine("");

            foreach ((var key, TsEnum tsEnum) in types.Enums)
            {
                RenderTsEnum(tsEnum, builder);
            }

            IList<TsType> sorted = TopologicalSort(
                types.Types.Values,
                v => v.Properties.Where(v=>v.TsType.IsT0).Select(v => v.TsType.AsT0));

            sorted = sorted.Where(v => types.Types.Values.Contains(v)).ToList();

            // sort by dependency graph
            foreach (TsType tsType in sorted)
            {
                RenderTsType(tsType, builder);
            }

            //builder.AppendLine("export declare module Entities {");

            //builder.AppendLine(entities.ToString());

            //builder.AppendLine($"  export type All = {string.Join(" | ", allEntityNames)}");
            //builder.AppendLine("}");
            builder.Insert(0, "\r\n");

            //builder.Insert(0, "/* eslint-disable prettier/prettier */");
            var text = builder.ToString();
            File.WriteAllText(path, text);
        }

        private static void RenderTsEnum(TsEnum type, StringBuilder builder)
        {
            var name = type.Name;
            builder.AppendLine($"export type {name} = {string.Join(" | ", type.Values.Select(v=>$@"""{v}"""))}");
            builder.AppendLine($@"export const default{name} = ""{type.DefaultValue}""");
            builder.AppendLine("");
        }

        private static void RenderTsType(TsType type, StringBuilder builder)
        {
            //var name = type.GenericTypeArguments.Length == 0
            //    ? type.Name.Replace(".", "")
            //    : type.GenericTypeArguments.Length == 1
            //        ? type.Name
            //            .Replace("`1", type.GenericTypeArguments[0].FullName)
            //            .Replace(".", "")
            //        : type.Name
            //            .Replace("`2", type.GenericTypeArguments[0].FullName + type.GenericTypeArguments[1].FullName)
            //            .Replace(".", "");
            //var fullName = type.FullName.Replace(".", "");

            var name = type.Name;
            builder.AppendLine($"export interface {name} {{");
            foreach (Property v in type.Properties)
            {
                builder.AppendLine($"  {v.PropertyName}: {v.TypeName}");
            }

            builder.AppendLine("}");
            builder.AppendLine("");

            if (type.DefaultValue != null)
            {
                builder.AppendLine($"export const default{name}: {name} = {{");
                foreach (Property property in type.Properties)
                {
                    builder.AppendLine($"  {property.PropertyName}: {property.DefaultValue ?? "null"},");
                }
                builder.AppendLine("}");
            }
            builder.AppendLine("");
        }

        public static IList<T> TopologicalSort<T>(
            IEnumerable<T> source,
            Func<T, IEnumerable<T>> getDependencies
        )
        {
            var sorted = new List<T>();
            var visited = new Dictionary<T, bool>();

            foreach (T item in source)
            {
                Visit(item, getDependencies, sorted, visited);
            }

            return sorted;
        }

        public static void Visit<T>(
            T item,
            Func<T, IEnumerable<T>> getDependencies,
            List<T> sorted,
            Dictionary<T, bool> visited
        )
        {
            if (item == null)
            {

            }
            var alreadyVisited = visited.TryGetValue(item, out var inProcess);

            if (alreadyVisited)
            {
                if (inProcess)
                {
                    throw new ArgumentException("Cyclic dependency found.");
                }
            }
            else
            {
                visited[item] = true;

                IEnumerable<T> dependencies = getDependencies(item);
                if (dependencies != null)
                {
                    foreach (T dependency in dependencies)
                    {
                        Visit(dependency, getDependencies, sorted, visited);
                    }
                }

                visited[item] = false;
                sorted.Add(item);
            }
        }
    }



}
