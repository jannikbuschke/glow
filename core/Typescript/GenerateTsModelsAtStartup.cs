using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Glow.TypeScript;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.ApiExplorer;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.VisualStudio.Services.Common;

namespace Glow.Core.Typescript
{

    public class GenerateTsModelsAtStartup : IHostedService
    {
        private readonly IApiDescriptionGroupCollectionProvider descriptionGroupCollectionProvider;
        private readonly IApiDescriptionProvider descriptionProvider;
        private readonly IWebHostEnvironment environment;
        private readonly AssembliesToScan assembliesToScan;
        private readonly ILogger<GenerateTsModelsAtStartup> logger;
        private readonly Options options;

        public GenerateTsModelsAtStartup(
            IApiDescriptionGroupCollectionProvider descriptionGroupCollectionProvider,
            IApiDescriptionProvider descriptionProvider,
            IWebHostEnvironment environment,
            AssembliesToScan assembliesToScan,
            ILogger<GenerateTsModelsAtStartup> logger,
            Options options
        )
        {
            this.descriptionGroupCollectionProvider = descriptionGroupCollectionProvider;
            this.descriptionProvider = descriptionProvider;
            this.environment = environment;
            this.assembliesToScan = assembliesToScan;
            this.logger = logger;
            this.options = options;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (!environment.IsDevelopment())
            {
                Console.WriteLine("Skip TS model generation");
                return Task.CompletedTask;
            }
            Console.WriteLine("Generate TS models");
            IEnumerable<Type> profileTypes = assembliesToScan.Value
                .SelectMany(v => v.GetTypes())
                .Where(v => v.IsSubclassOf(typeof(TypeScriptProfile)));

            var entities = new StringBuilder();
            var allEntityNames = new List<string>();

            var builder = new StringBuilder();
            builder.AppendLine($"/* this file is autogenerated. Do not edit. */");
            builder.AppendLine("");

            // duplication?
            profileTypes.Select(v => Activator.CreateInstance(v) as TypeScriptProfile)
                .ForEach(type =>
                {
                    Extensions2.AddAllTypes(type.Types);
                });

            // search for all attributes
            IEnumerable<Type> additionalTypes = assembliesToScan.Value
                .SelectMany(v => v.GetExportedTypes()
                .Where(x => x.GetCustomAttributes(typeof(GenerateTsInterface), true).Any()));

            Extensions2.AddAllTypes(additionalTypes);

            foreach (Type type in Extensions2.AllTypes())
            {
                Render(type, builder, entities, allEntityNames);
            }

            //foreach (Type profileType in profileTypes)
            //{
            //    // duplication?
            //    var profile = Activator.CreateInstance(profileType) as TypeScriptProfile;

            //    foreach (Type type in profile.Types)
            //    {
            //        Render(type, builder, entities, allEntityNames);
            //    }
            //}
            //foreach (Type type in GenerateApiClientsAtStartup.CustomTypes)
            //{
            //    Render(type, builder, entities, allEntityNames);
            //}
            //foreach (Type type in additionalTypes)
            //{
            //    Render(type, builder, entities, allEntityNames);
            //}

            builder.AppendLine("export declare module Entities {");

            builder.AppendLine(entities.ToString());

            builder.AppendLine($"  export type All = {string.Join(" | ", allEntityNames)}");
            builder.AppendLine("}");
            builder.Insert(0, "\r\n");

            //builder.Insert(0, "/* eslint-disable prettier/prettier */");
            var path = $"{options.GetPath()}ts-models.ts";
            var text = builder.ToString();
            File.WriteAllText(path, text);

            return Task.CompletedTask;

        }

        private static void Render(Type type, StringBuilder builder, StringBuilder entities, List<string> allEntities)
        {
            var name = type.GenericTypeArguments.Length == 0
                ? type.Name.Replace(".", "")
                : type.GenericTypeArguments.Length == 1
                    ? type.Name
                        .Replace("`1", type.GenericTypeArguments[0].FullName)
                        .Replace(".", "")
                    : type.Name
                        .Replace("`2", type.GenericTypeArguments[0].FullName + type.GenericTypeArguments[1].FullName)
                        .Replace(".", "");
            var fullName = type.FullName.Replace(".", "");
            allEntities.Add(name);

            Console.WriteLine("export " + name);

            entities.AppendLine(@$"  export type {name} = ""{fullName}""");

            builder.AppendLine($"export interface {name} {{");
            type.GetProperties(BindingFlags.Public | BindingFlags.Instance).ForEach(v =>
            {
                builder.AppendLine($"  {v.Name.CamelCase()}: {v.PropertyType.ToTsType()}");
            });
            builder.AppendLine("}");
            builder.AppendLine("");

            builder.AppendLine($"export const default{name}: {name} = {{");
            type.GetProperties(BindingFlags.Public | BindingFlags.Instance).ForEach(v =>
            {
                var value = v.PropertyType.DefaultValue();// v.PropertyType.IsValueType ? Activator.CreateInstance(v.PropertyType) : "null";
                builder.AppendLine($"  {v.Name.CamelCase()}: {value ?? "null"},");
            });
            builder.AppendLine("}");
            builder.AppendLine("");
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }

    public static class Extensions2
    {
        private static readonly Dictionary<Type, string> typeDictionary = new Dictionary<Type, string>
            {
                { typeof(string), "string | null" },
                { typeof(int), "number" },
                { typeof(int?), "number | null" },
                { typeof(DateTime), "string" },
                { typeof(DateTime?), "string | null" },
                { typeof(Guid), "string" },
                { typeof(Guid?), "string | null" },
                { typeof(bool), "boolean" },
                { typeof(bool?), "boolean | null" },
                { typeof(Dictionary<string, string>), "{ [key: string]: string }" },
                { typeof(Dictionary<string, int>), "{ [key: string]: number }" },
                { typeof(Dictionary<string, object>), "{ [key: string]: any }" },
                { typeof(object), "any" }
            };

        public static IEnumerable<Type> AllTypes()
        {
            return typeDictionary.Keys;
        }

        private static readonly Dictionary<Type, string> defaults = new Dictionary<Type, string>
            {
                { typeof(string), @"""""" },
                { typeof(int), "0" },
                { typeof(int?), "null" },
                { typeof(DateTime), @"""1/1/0001 12:00:00 AM""" },
                { typeof(DateTime?), "null" },
                { typeof(Guid), @"""00000000-0000-0000-0000-000000000000""" },
                { typeof(Guid?), "null" },
                { typeof(bool), "false" },
                { typeof(bool?), "null" },
                { typeof(Dictionary<string, string>), "{}" },
                { typeof(Dictionary<string, int>), "{}" },
                { typeof(Dictionary<string, object>), "{}" },
            };

        public static void AddAllTypes(IEnumerable<Type> types)
        {
            types.ForEach(v => AddType(v));
        }

        public static void AddType(Type type)
        {
            typeDictionary.TryAdd(type, type.Name);
        }

        private static bool IsNullable(Type type)
        {
            return Nullable.GetUnderlyingType(type) != null;
        }

        public static string ToTsType(this Type t)
        {
            Dictionary<Type, string> types = typeDictionary;

            if (IsNullable(t))
            {
                Type underlyingType = Nullable.GetUnderlyingType(t);
                if (underlyingType.IsEnum)
                {
                    return RenderEnumValues(underlyingType) + " | null";
                }
            }

            if (t.IsEnum)
            {
                return RenderEnumValues(t);
            }

            if (types.TryGetValue(t, out var result))
            {
                return result;
            }

            if (t.IsEnumerable())
            {
                return $"{(t.GetGenericArguments().FirstOrDefault() ?? typeof(object)).ToTsType()}[]";
            }

            return "any";
        }

        public static string DefaultValue(this Type t)
        {
            //var types = typeDictionary;


            if (defaults.TryGetValue(t, out var result))
            {
                return result;
            }

            if (t.IsEnumerable())
            {
                return "[]";
            }

            if (typeDictionary.ContainsKey(t) && t.ToTsType() != "any")
            {
                return "default" + t.ToTsType();
            }

            if (t.IsEnum)
            {
                return $@"""{GetEnumValues(t).FirstOrDefault()}""";
            }

            if (IsNullable(t))
            {
                return "null";
            }

            return "null as any";// $"default{t.Name}";
        }

        private static IEnumerable<string> GetEnumValues(Type t)
        {
            Array values = Enum.GetValues(t);
            foreach (var val in values)
            {
                yield return Enum.GetName(t, val);
            }
        }

        private static string RenderEnumValues(Type t)
        {
            var r = new List<string>();
            foreach (var val in GetEnumValues(t))
            {
                r.Add($@"""{val}""");
            }
            return string.Join(" | ", r);
        }
    }
}
